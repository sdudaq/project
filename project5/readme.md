# SM2 数字签名算法（Python 实现）

本项目提供了基于国密 SM2 椭圆曲线密码算法的**纯 Python 实现**，包括签名和验证功能，并附带优化版本以提升性能和安全性。

## 项目介绍

SM2 是中国国家密码管理局制定的椭圆曲线公钥密码算法，广泛应用于电子认证和数字签名场景。本项目提供两种版本的实现：

- `SM2`：基础实现，便于理解算法原理；
- `SM2_Optimized`：包含多个性能和安全性优化点，适合实际应用测试。
## 项目结构
```
├── sm2_basic.py     # 基础版实现（仿射坐标）
├── sm2_optimized.py # 优化版实现（Jacobian坐标 + secrets）
├── README.md        # 本说明文件
```
## 依赖环境

- Python 3.6+
- `gmssl`库用于 SM3 哈希计算

安装依赖：

```bash
pip install gmssl

```

# SM2 数字签名算法流程

## 密钥生成

1. **私钥选择**  
   随机选择私钥 `d`，满足：  
   `d ∈ [1, n - 1]`  
   （`n` 为椭圆曲线的阶）

2. **公钥计算**  
   计算公钥点：  
   `P = [d]G`  
   （`G` 为椭圆曲线基点）

---

## 签名过程

给定消息 `M`，签名流程如下：

1. **消息哈希**  
   使用 SM3 算法计算消息摘要：  
   `e = Hash(M)`

2. **随机数生成**  
   选取随机整数 `k`，满足：  
   `k ∈ [1, n - 1]`

3. **椭圆曲线点乘**  
   计算临时点：  
   `(x₁, y₁) = [k]G`

4. **计算 r 值**  
   `r = (e + x₁) mod n`  
   **校验**：  
   - 若 `r = 0` 或 `r + k = n`，需重新选择 `k`

5. **计算 s 值**  
   `s = ((1 + d)⁻¹ * (k - r*d)) mod n`  
   **校验**：  
   - 若 `s = 0`，需重新选择 `k`

6. **签名输出**  
   最终签名为：  
   `(r, s)`

---

## 验证过程

给定消息 `M` 和签名 `(r, s)`，验证流程如下：

1. **消息哈希**  
   计算相同摘要：  
   `e = Hash(M)`

2. **中间值计算**  
   `t = (r + s) mod n`  
   **校验**：  
   - 若 `t = 0`，立即判定签名无效

3. **椭圆曲线运算**  
   计算点：  
   `(x₁, y₁) = [s]G + [t]P`

4. **签名有效性判定**  
   计算：  
   `R = (e + x₁) mod n`  
   **验证条件**：  
   `R == r` → 签名有效  
   `R ≠ r` → 签名无效

---

## 注意事项

1. **安全要求**：
   - 每次签名必须使用不可预测的新随机数 `k`
   - 建议使用 RFC 6979 的确定性 `k` 生成方案

2. **边界条件**：
   ```python
   # 伪代码示例
   if r == 0 or r + k == n or s == 0:
       return "需要重新生成k"